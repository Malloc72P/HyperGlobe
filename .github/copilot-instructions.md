# StudyMate — AI 코딩 에이전트 가이드

### 답변 기본 규칙

- 항상 한국어로 답변한다.
- 아래 문서를 수시로 참고한다: `docs/서비스_기획서.md`.
- 답변은 간결하고 명확하게 한다.
- 글을 작문할 때, 모던한 한국어 문체를 사용한다. 단, 그렇다고 해서 과도한 영어 표현은 피한다.
- 사용자의 지시가 모호한 경우, 반드시 추가질문을 통해 모호한 부분을 명확히 한다.
- copilot-instructions.md 문서에 명시된 규칙을 우선시한다. 작업 완료 후, 지시사항을 어긴 부분이 없는지 반드시 검토한다.
- 만약 지시사항에 모순이 있거나, 지시사항을 따르기 어려운 경우, 그 이유를 설명하고 사용자에게 문의한다.
- 사용자가 수정해달라고 요청하는 것이 아니라면, 답변만 한다. 코드를 수정하거나 명령어를 대신 실행하지 않는다.

### 코딩 규칙

- 코드 예시는 TypeScript 환경에 맞춘다.
- 코드 예시에서 `any` 타입 사용은 지양한다. 단, 테스트 코드에선 예외적으로 허용할 수 있다. 다만 불필요한 any 사용은 지양해야 한다.
- non-null assertion는 절대 사용하지 않는다. 대신 타입 가드나 타입 좁히기로 해당 연산자를 사용할 상황을 만들지 않는다.
- object possibly undefined 오류가 발생하지 않도록 타입 가드를 위한 코드를 작성한다.

### 새로운 기술 도입에 대한 규칙

- 새로운 기술 도입 시 장단점을 간략히 설명한다.
- 새로운 기술 도입 시 기존 코드와의 일관성을 고려한다.
- 새로운 라이브러리를 도입하는 경우 최신 버전을 기준으로 한다.

### apps/www 가이드

## 프로젝트 계획

### 1주차: "Hello, 3D World!" - 환경 구축 및 기본 렌더링금

- **목표**: 3D 렌더링을 위한 기본 환경을 설정하고, 화면에 회전하는 구(Sphere)를 띄웁니다.
- **What (무엇을)**:
  1.  **프로젝트 설정**: Vite, React, TypeScript, Three.js, react-three-fiber(R3F), drei 라이브러리를 설치하여 개발 환경을 구성합니다.
  2.  **`Canvas` 컴포넌트 설정**: R3F의 `<Canvas>` 컴포넌트를 사용해 3D 장면을 렌더링할 영역을 만듭니다.
  3.  **기본 도형(Mesh) 렌더링**: `<mesh>` 컴포넌트를 사용하여 화면에 구(`sphereGeometry`)를 렌더링합니다.
  4.  **카메라 제어 추가**: `drei` 라이브러리의 `<OrbitControls>`를 추가하여 마우스로 구를 회전하고 줌인/아웃 할 수 있게 만듭니다.
  5.  **애니메이션**: R3F의 `useFrame` 훅을 사용하여 매 프레임마다 구를 조금씩 회전시켜 움직임을 줍니다.
- **Why (왜)**:
    - 이 단계는 3D 그래픽스의 "Hello, World"입니다. `Scene`, `Camera`, `Renderer`, `Mesh` 등 **Three.js의 가장 기본적인 개념들이 R3F에서 어떻게 컴포넌트로 표현되는지** 직접 체험하고 익숙해지는 과정입니다.
    - `<OrbitControls>`를 먼저 추가하는 이유는, 복잡한 카메라 수학 계산 없이도 **가장 기본적인 상호작용을 쉽게 구현**할 수 있게 해주어 개발 초기 단계의 허들을 크게 낮춰주기 때문입니다.

---

### 2주차: 데이터와 3D 공간의 연결 - 좌표 변환 및 데이터 시각화

- **목표**: 위도/경도 좌표를 3D 공간의 좌표로 변환하고, 이 데이터를 기반으로 구 표면에 점들을 표시합니다.
- **What (무엇을)**:
  1.  **좌표 변환 함수 작성**: `[경도, 위도]` 배열을 인자로 받아 구 표면의 `[x, y, z]` 좌표(Vector3)로 변환하는 유틸리티 함수를 만듭니다. (삼각함수 지식이 약간 필요하지만, 관련 예제 코드가 많습니다.)
  2.  **샘플 데이터 준비**: 도시들의 위도/경도 정보가 담긴 간단한 JSON 파일을 준비합니다.
  3.  **데이터 매핑 및 렌더링**: JSON 데이터를 불러와 각 도시의 좌표를 3D 좌표로 변환한 후, 해당 위치에 작은 구(`sphereGeometry`)나 점(`points`)을 렌더링합니다.
- **Why (왜)**:
    - 이 단계는 **프로젝트의 가장 핵심적인 로직을 구현**하는 과정입니다. 2D 지도에서 좌표를 다루었던 경험을 3D 공간으로 확장하는 중요한 단계입니다.
    - 데이터(추상적 정보)를 3D 공간의 시각적 요소로 **성공적으로 변환하는 파이프라인을 구축**함으로써, 앞으로 구현할 모든 시각화 기능의 기반을 마련하게 됩니다.

---

### 3주차: "지구본" 만들기 - 텍스처와 빛

- **목표**: 단순한 구를 실제 지구본처럼 보이게 만들고, 입체감을 더합니다.
- **What (무엇을)**:
  1.  **텍스처 매핑**: 지구본 모양의 이미지 파일(Equirectangular map texture)을 구 표면에 입힙니다. `useLoader` 훅과 `TextureLoader`를 사용합니다.
  2.  **기본적인 빛 추가**: `<ambientLight>`(전체적으로 은은하게 비추는 빛)와 `<directionalLight>`(태양처럼 특정 방향에서 비추는 빛)를 장면에 추가하여 입체감을 살립니다.
  3.  **(심화) 구름, 별 배경 추가**: 지구본보다 약간 더 큰 구에 구름 텍스처를 입히고, 아주 큰 구의 안쪽에 별 이미지 텍스처를 입혀 우주 공간 느낌을 연출합니다.
- **Why (왜)**:
  - 지금까지는 구조와 로직에 집중했다면, 이제부터는 **시각적 퀄리티**를 높이는 단계입니다. 텍스처는 포트폴리오의 첫인상을 결정하는 가장 중요한 요소입니다.
  - 빛(Light)은 3D 그래픽스에서 **입체감과 사실감을 부여하는 핵심 요소**입니다. 빛이 없으면 모든 것은 단색으로 보입니다. 빛의 종류와 위치에 따라 결과물이 어떻게 달라지는지 이해하게 됩니다.

---

### 4주차: 생동감 부여하기 - 인터랙션 및 연결선 시각화

- **목표**: 사용자가 시각화된 데이터와 상호작용할 수 있게 만들고, 데이터 간의 관계를 표현합니다.
- **What (무엇을)**:
  1.  **호(Arc) 시각화**: 두 지점(데이터 포인트)을 잇는 곡선을 그립니다. 두 3D 좌표 사이의 중간점을 계산하여 곡선(Cubic Bezier Curve) 지오메트리를 생성하는 방식으로 구현합니다.
  2.  **이벤트 처리**: 2주차에 생성한 데이터 포인트 메시에 `onPointerOver`(마우스 올리기), `onPointerOut`, `onClick` 같은 이벤트 핸들러를 추가합니다.
  3.  **툴팁(Tooltip) 구현**: 데이터 포인트에 마우스를 올리면 해당 도시의 이름 같은 정보가 담긴 툴팁을 표시합니다. (성능과 편의성을 위해 3D 공간이 아닌, **HTML `div` 엘리먼트를 좌표에 맞게 띄우는 방식**을 추천합니다.)
- **Why (왜)**:
  - 정적인 시각화에 **동적인 사용자 경험(UX)을 더하는** 단계입니다. 인터랙션은 사용자의 흥미를 유발하고 정보 탐색을 가능하게 합니다.
  - 호(Arc) 시각화는 '항공 경로', '데이터 이동' 등 관계성을 보여주는 강력한 시각적 장치로, 포트폴리오를 한층 더 다채롭게 만들어 줍니다.

---

### 5주차: 재사용성을 위한 설계 - 라이브러리 API화

- **목표**: 지금까지 만든 기능들을 재사용 가능한 React 컴포넌트로 캡슐화하고, 명확한 API(props)를 설계합니다.
- **What (무엇을)**:
  1.  **컴포넌트 리팩토링**: 전체 로직을 `<GeoVisGlobe>`와 같은 단일 컴포넌트로 묶습니다.
  2.  **Props 기반 API 설계**: 데이터, 마커 색상, 호(arc) 색상, 지구본 텍스처 등 시각화의 주요 요소들을 `props`로 받아 동적으로 변경할 수 있도록 API를 설계합니다. (예: `<GeoVisGlobe data={myData} markerColor="red" />`)
  3.  **문서화 사이트 구축 시작**: `Nextra` 혹은 `Storybook`을 사용하여 라이브러리를 소개하고, 설계한 `props`를 어떻게 사용하는지 보여주는 기본 예제 페이지를 만듭니다.
- **Why (왜)**:
  - 이 단계는 **단순한 '프로젝트'를 '포트폴리오(라이브러리)'로 격상시키는** 가장 중요한 과정입니다.
  - 컴포넌트를 API화하는 경험을 통해 재사용성, 확장성 등 소프트웨어 설계 원칙을 고민하게 됩니다. 이는 **라이브러리 개발자로서의 역량**을 직접적으로 보여주는 결과물이 됩니다.

---

### 6주차: 완성도 향상 및 배포

- **목표**: 성능을 최적화하고, 문서 사이트를 완성하여 외부에 공개할 수 있는 수준으로 만듭니다.
- **What (무엇을)**:
  1.  **성능 최적화**: 수백, 수천 개의 데이터 포인트를 렌더링할 때 발생할 수 있는 성능 저하를 막기 위해 `InstancedMesh`를 적용해 봅니다. (동일한 모양의 메시를 훨씬 효율적으로 그리는 기술)
  2.  **데모 페이지 완성**: 문서화 사이트에 라이브러리의 다양한 옵션을 실시간으로 바꿔보며 테스트할 수 있는 인터랙티브한 데모 페이지를 만듭니다.
  3.  **CI/CD 및 배포**: `GitHub Actions`를 사용하여 문서 사이트가 `main` 브랜치에 푸시될 때마다 `Vercel`이나 `GitHub Pages`에 자동으로 배포되도록 파이프라인을 구성합니다.
  4.  **README 작성**: 프로젝트의 목적, 기술 스택, 설치 및 사용법, 주요 기능 등을 상세히 담은 `README.md` 파일을 작성합니다.
- **Why (왜)**:
  - 성능 최적화는 대용량 데이터를 다루는 시각화 라이브러리의 **품질을 결정**하는 중요한 요소입니다. `InstancedMesh` 적용 경험은 3D 그래픽스 성능에 대한 이해도를 보여줍니다.
  - 자동화된 배포 파이프라인과 상세한 문서는 **체계적인 개발 프로세스와 협업 역량**을 어필할 수 있는 좋은 증거입니다.
  