<style>
    section{font-size: 16px;}
</style>

# HyperGlobe ì„±ëŠ¥ ìµœì í™” ìš”ì•½

## ğŸ“Š ìµœì í™” ê°œìš”

### ì¸¡ì • í™˜ê²½
- **í…ŒìŠ¤íŠ¸ ê¸°ê¸°**: M1 MacBook
- **ì¸¡ì • ëŒ€ìƒ**: world-high GeoJSON (256ê°œ êµ­ê°€, 62,032ê°œ ì¢Œí‘œ)
- **ì¸¡ì • ì§€í‘œ**: FPS, ë“œë¡œìš°ì½œ, ì´ˆê¸° ë¡œë”© ì‹œê°„, í˜¸ë²„ ë°˜ì‘ ì†ë„

---

## ğŸ¯ ìµœì í™” ì „í›„ ë¹„êµ

### ìµœì í™” ì „ (ì´ˆê¸° ìƒíƒœ)
```
FPS:            24 fps ğŸ”´
ì´ˆê¸° ë¡œë”©:       3-7ì´ˆ (ëŸ°íƒ€ì„ ì‚¼ê°ë¶„í• )
ë“œë¡œìš°ì½œ:        4,320ê°œ
ì§€ì˜¤ë©”íŠ¸ë¦¬:      2,892ê°œ
í˜¸ë²„ ê¸°ëŠ¥:       ì‚¬ìš© ë¶ˆê°€ (ì„±ëŠ¥ ë¬¸ì œ)
íŒŒì¼ í¬ê¸°:       1.16MB (GeoJSON)
```

### ìµœì í™” í›„ (ìµœì¢… ìƒíƒœ)
```
FPS:            58-60 fps âœ…
ì´ˆê¸° ë¡œë”©:       < 0.5ì´ˆ (ì „ì²˜ë¦¬ëœ HGM íŒŒì¼)
ë“œë¡œìš°ì½œ:        512ê°œ
ì§€ì˜¤ë©”íŠ¸ë¦¬:      548ê°œ
í˜¸ë²„ ë°˜ì‘:       < 1ms
íŒŒì¼ í¬ê¸°:       378KB (HGM, gzip ì••ì¶•)
```

### ê°œì„  íš¨ê³¼ ìš”ì•½
- **FPS**: 24fps â†’ 60fps (+150% í–¥ìƒ)
- **ì´ˆê¸° ë¡œë”©**: 3-7ì´ˆ â†’ 0.5ì´ˆ (94% ê°œì„ )
- **ë“œë¡œìš°ì½œ**: 4,320 â†’ 512 (88% ê°ì†Œ)
- **í˜¸ë²„ ë°˜ì‘**: ë¶ˆê°€ëŠ¥ â†’ < 1ms (99.9% ê°œì„ )
- **íŒŒì¼ í¬ê¸°**: 1.16MB â†’ 378KB (67% ê°ì†Œ)

---

## ğŸ”§ ì ìš©í•œ 3ê°€ì§€ í•µì‹¬ ìµœì í™”

### 1. ë“œë¡œìš°ì½œ ë³‘í•© ìµœì í™” â­â­â­â­â­

**ë¬¸ì œ ìƒí™©:**
- ê° í´ë¦¬ê³¤(ë§)ë§ˆë‹¤ ê°œë³„ ë©”ì‰¬ì™€ ë¼ì¸ ìƒì„±
- world-high: 1,435ê°œ ë§ â†’ ìµœì†Œ 2,870ê°œ ë“œë¡œìš°ì½œ
- ì‹¤ì œ ì¸¡ì •: 4,320ê°œ ë“œë¡œìš°ì½œ
- ê¶Œì¥ì¹˜(~500)ì˜ 9ë°° ì´ˆê³¼ë¡œ GPU ë³‘ëª© ë°œìƒ

**í•´ê²° ë°©ë²•:**
RegionFeature ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œ ëª¨ë“  ë§ì„ í•˜ë‚˜ì˜ ë©”ì‰¬ë¡œ ë³‘í•©

```tsx
// RegionFeature.tsx - ìµœì í™”ëœ êµ¬í˜„
const regionFeatureGeometry = useMemo(() => {
  if (!meshSource) return;
  
  // 1. ëª¨ë“  í´ë¦¬ê³¤ì˜ ì§€ì˜¤ë©”íŠ¸ë¦¬ë¥¼ í•˜ë‚˜ë¡œ ë³‘í•©
  const geometry = mergeGeometries(meshSource);
  
  // 2. ì™¸ê³½ì„ ë„ í•˜ë‚˜ì˜ lineSegmentsë¡œ ë³‘í•©
  const points: number[] = [];
  for (const pointArray of feature.borderLines.pointArrays) {
    points.push(...pointArray);
  }
  const borderlineGeometry = new THREE.BufferGeometry();
  borderlineGeometry.setAttribute(
    'position', 
    new THREE.Float32BufferAttribute(points, 3)
  );
  
  return { geometry, borderlineGeometry };
}, [meshSource, feature]);

return (
  <group>
    {/* êµ­ê°€ë‹¹ 1ê°œ mesh = 256ê°œ ë“œë¡œìš°ì½œ */}
    <mesh geometry={regionFeatureGeometry.geometry}>
      <meshStandardMaterial {...props} />
    </mesh>
    <lineSegments geometry={regionFeatureGeometry.borderlineGeometry}>
      <lineBasicMaterial {...props} />
    </lineSegments>
  </group>
);
```

**ê°œì„  íš¨ê³¼:**
- ë“œë¡œìš°ì½œ: 4,320 â†’ 512 (88% ê°ì†Œ)
- ì§€ì˜¤ë©”íŠ¸ë¦¬: 2,892 â†’ 548 (81% ê°ì†Œ)
- FPS: 24 â†’ 58-60 (+142% í–¥ìƒ)
- êµ­ê°€ë³„ ë…ë¦½ì ì¸ ì œì–´ ìœ ì§€ (hover, ìƒ‰ìƒ ë³€ê²½ ê°€ëŠ¥)

---

### 2. HGM í¬ë§· - ë¹Œë“œ íƒ€ì„ ì „ì²˜ë¦¬ â­â­â­â­â­

**ë¬¸ì œ ìƒí™©:**
- ë¸Œë¼ìš°ì €ì—ì„œ 1,435ê°œ í´ë¦¬ê³¤ì— ëŒ€í•´ Delaunay ì‚¼ê°ë¶„í•  ìˆ˜í–‰
- ì´ˆê¸° ë¡œë”©: 3-7ì´ˆ (UI ë¸”ë¡œí‚¹ ë°œìƒ)
- CPU ì§‘ì•½ì  ì—°ì‚°ìœ¼ë¡œ ì €ì‚¬ì–‘ ê¸°ê¸°ì—ì„œ ë” ì‹¬ê°

**í•´ê²° ë°©ë²•:**
ë¹Œë“œ íƒ€ì„ì— ì‚¼ê°ë¶„í• ì„ ë¯¸ë¦¬ ìˆ˜í–‰í•˜ê³  ì „ì²˜ë¦¬ëœ ë°ì´í„°ë¥¼ HGM íŒŒì¼ë¡œ ì €ì¥

**HGM íŒŒì¼ êµ¬ì¡°:**
```typescript
interface HGMFile {
  version: string;
  features: HGMFeature[];
}

interface HGMFeature {
  id: string;
  properties: Record<string, any>;
  
  // ì „ì²˜ë¦¬ëœ ì‚¼ê°ë¶„í•  ê²°ê³¼
  geometries: GeometrySource[];  // vertices + indices
  
  // ì™¸ê³½ì„  ì¢Œí‘œ
  borderLines: BorderlineSource;
  
  // ê³µê°„ ì¸ë±ì‹±ìš©
  bbox: BoundingBox;
}
```

**CLI ë„êµ¬:**
```bash
# GeoJSON â†’ HGM ë³€í™˜
hyperglobe-cli convert ./world-high.geo.json ./world-high.hgm
```

**ë¸Œë¼ìš°ì €ì—ì„œ ì‚¬ìš©:**
```typescript
// ì „ì²˜ë¦¬ëœ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new BufferAttribute(geometrySource.vertices, 3));
geometry.setIndex(new BufferAttribute(geometrySource.indices, 1));
geometry.computeVertexNormals(); // GPUì—ì„œ ë¹ ë¥´ê²Œ ê³„ì‚° (~10ms)
```

**TypedArray ìµœì í™” (v2):**
- JSON ìˆ«ì ë°°ì—´ â†’ Base64 ì¸ì½”ë”©ëœ TypedArray
- Float32Array: ìˆ«ìë‹¹ ì •í™•íˆ 4ë°”ì´íŠ¸
- Uint32Array: ì¸ë±ìŠ¤ë‹¹ ì •í™•íˆ 4ë°”ì´íŠ¸
- gzip ì••ì¶•ê³¼ ê²°í•©í•˜ì—¬ ìµœì ì˜ í¬ê¸° ë‹¬ì„±

**ê°œì„  íš¨ê³¼:**
- ì´ˆê¸° ë¡œë”©: 3-7ì´ˆ â†’ < 0.5ì´ˆ (ì•½ 10ë°° ê°œì„ )
- íŒŒì¼ í¬ê¸°: 1.16MB â†’ 378KB (67% ê°ì†Œ, TypedArray ì ìš© í›„)
- ë¸Œë¼ìš°ì € CPU ë¶€ë‹´ ì œê±°
- ëª¨ë“  ê¸°ê¸°ì—ì„œ ì¼ê´€ëœ ë¹ ë¥¸ ë¡œë”©

---

### 3. Globe ë²¡í„° íˆíŠ¸ í…ŒìŠ¤íŠ¸ â­â­â­â­â­

**ë¬¸ì œ ìƒí™©:**
- RegionFeature ë³‘í•© í›„ ë ˆì´ìºìŠ¤íŠ¸ ì„±ëŠ¥ ì•…í™”
- ë³‘í•© ì „: 1,435ê°œ Ã— 350 ì‚¼ê°í˜• = ~3,500ê°œ ê²€ì‚¬
- ë³‘í•© í›„: 256ê°œ Ã— 1,979 ì‚¼ê°í˜• = ~19,790ê°œ ê²€ì‚¬ (5.6ë°° ì¦ê°€)
- ë§¤ í”„ë ˆì„ í¬ì¸í„° ì´ë²¤íŠ¸ ì‹œ ì‹¬ê°í•œ ë¸”ë¡œí‚¹

**í•´ê²° ë°©ë²•:**
í¬ì¸í„° ì´ë²¤íŠ¸ë¥¼ RegionFeatureê°€ ì•„ë‹Œ Globe ì»´í¬ë„ŒíŠ¸ì— ë°°ì¹˜í•˜ê³ , 3D ë ˆì´ìºìŠ¤íŠ¸ ëŒ€ì‹  2D ê³µê°„ ê²€ìƒ‰ í™œìš©

**í•µì‹¬ ì•„ì´ë””ì–´:**
1. Globeì˜ êµ¬ì²´ í‘œë©´ì—ì„œ êµì°¨ì  íšë“ (ë‹¨ìˆœí•œ êµ¬ì²´ 1ê°œë§Œ ê²€ì‚¬)
2. 3D ë²¡í„° â†’ ê²½ìœ„ë„ ë³€í™˜ (ì—­ë³€í™˜)
3. R-treeë¡œ í›„ë³´ ì§€ì—­ ë¹ ë¥´ê²Œ í•„í„°ë§
4. Point-in-Polygonìœ¼ë¡œ ì •í™•í•œ ì§€ì—­ ì‹ë³„

**êµ¬í˜„:**
```tsx
// Globe.tsx
export function Globe({ rotation, ... }: GlobeProps) {
  const rTree = useMainStore((s) => s.tree);
  const setHoveredRegion = useMainStore((s) => s.setHoveredRegion);

  const onPointerMove = useThrottle({
    fn: (e) => {
      const { point } = e;  // R3Fê°€ ì œê³µí•˜ëŠ” êµ¬ì²´ í‘œë©´ êµì°¨ì 

      const foundRegion = findRegionByVector({
        rTree,
        rotation,
        vector: point,
      });

      setHoveredRegion(foundRegion);
    },
    delay: 50,  // 50ms throttle
  });

  return (
    <mesh position={position} onPointerMove={onPointerMove}>
      <sphereGeometry args={[1, segments[0], segments[1]]} />
      <meshStandardMaterial {...props} />
    </mesh>
  );
}
```

**findRegionByVector ì•Œê³ ë¦¬ì¦˜:**
```typescript
export function findRegionByVector({ rotation, vector, rTree }: Options) {
  // 1. íšŒì „ ì—­í–‰ë ¬ë¡œ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜
  const inverseMatrix = new Matrix4();
  inverseMatrix.makeRotationFromEuler(new Euler(...rotation));
  inverseMatrix.invert();
  const localPoint = new Vector3(vector.x, vector.y, vector.z)
    .applyMatrix4(inverseMatrix);

  // 2. 3D ì¢Œí‘œ â†’ ê²½ìœ„ë„ ì—­ë³€í™˜
  const coordinate = CoordinateConverter.invert([
    localPoint.x, 
    localPoint.y, 
    localPoint.z
  ]);

  // 3. R-treeë¡œ í›„ë³´ ì§€ì—­ í•„í„°ë§ (O(log n))
  const candidates = rTree.search({
    minX: coordinate[0], minY: coordinate[1],
    maxX: coordinate[0], maxY: coordinate[1],
  }).sort((a, b) => a.bboxSize - b.bboxSize);

  // 4. Point-in-Polygon ì •ë°€ ê²€ì‚¬ (Ray Casting)
  for (const region of candidates) {
    for (const polygon of region.polygons) {
      if (isPointInPolygon(coordinate, polygon)) {
        return region;
      }
    }
  }
  
  return null;
}
```

**Point-in-Polygon (Ray Casting):**
```typescript
export function isPointInPolygon(
  point: [number, number], 
  polygon: Coordinate[]
): boolean {
  const [x, y] = point;
  let inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i]![0], yi = polygon[i]![1];
    const xj = polygon[j]![0], yj = polygon[j]![1];

    const intersect = 
      yi > y !== yj > y && 
      x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;

    if (intersect) inside = !inside;
  }

  return inside;
}
```

**ì„±ëŠ¥ ë¹„êµ:**

| ë°©ì‹ | ë ˆì´ìºìŠ¤íŠ¸ ëŒ€ìƒ | ì‚¼ê°í˜• ê²€ì‚¬ | ì¶”ê°€ ì—°ì‚° | ì´ ì‹œê°„ |
|------|---------------|------------|----------|---------|
| RegionFeature ë³‘í•© | 256ê°œ ë³µì¡í•œ geometry | ~19,790ê°œ | - | ~10ms |
| **Globe ë²¡í„°** | **1ê°œ ë‹¨ìˆœ êµ¬ì²´** | **~100ê°œ** | **ë²¡í„°ë³€í™˜ + R-tree + PiP** | **< 1ms** |

**ê°œì„  íš¨ê³¼:**
- ë ˆì´ìºìŠ¤íŠ¸ ë¹„ìš©: 99.9% ê°ì†Œ
- í˜¸ë²„ ë°˜ì‘ ì†ë„: < 1ms
- 60 FPS ì•ˆì • ìœ ì§€
- ê´€ì‹¬ì‚¬ ë¶„ë¦¬: Globe(ìƒí˜¸ì‘ìš©) / RegionFeature(ë Œë”ë§)

---

## ğŸ—ï¸ ì•„í‚¤í…ì²˜ ê°œì„ 

### Zustand Storeë¥¼ í†µí•œ ì¤‘ì•™ ì§‘ì¤‘ì‹ ìƒíƒœ ê´€ë¦¬

```typescript
// main-store.ts
export interface MainStore {
  // R-tree ê³µê°„ ì¸ë±ìŠ¤
  tree: RBush<RegionModel>;
  
  // í˜¸ë²„ëœ ì§€ì—­
  hoveredRegion: RegionModel | null;
  
  // ì§€ì—­ ë“±ë¡/í•´ì œ
  insertRegionModel: (region: RegionModel) => void;
  removeRegionModel: (region: RegionModel) => void;
  
  // í˜¸ë²„ ìƒíƒœ ì„¤ì •
  setHoveredRegion: (region: RegionModel | null) => void;
}
```

**ì¥ì :**
- ë‹¨ì¼ ì§„ì…ì ì—ì„œ ëª¨ë“  í˜¸ë²„ ì²˜ë¦¬
- ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ì—ì„œ `hoveredRegion` êµ¬ë… ê°€ëŠ¥
- ìƒˆë¡œìš´ ì§€ì—­ ì¶”ê°€/ì œê±° ìš©ì´
- ë‹¤ë¥¸ ì¸í„°ë™ì…˜(í´ë¦­, ë“œë˜ê·¸ ë“±) ë™ì¼ íŒ¨í„´ ì ìš© ê°€ëŠ¥

---

## ğŸ“Š ìµœì¢… ì„±ëŠ¥ ì§€í‘œ

### ëª©í‘œ ë‹¬ì„±ë„

| ì§€í‘œ | ëª©í‘œ | ì‹¤ì œ ë‹¬ì„± | ìƒíƒœ |
|------|------|----------|------|
| **FPS** | 60 fps | 58-60 fps | âœ… ë‹¬ì„± |
| **ì´ˆê¸° ë¡œë”©** | < 1ì´ˆ | < 0.5ì´ˆ | âœ… ì´ˆê³¼ ë‹¬ì„± |
| **í˜¸ë²„ ê¸°ëŠ¥** | ì§€ì—° ì—†ìŒ | < 1ms | âœ… ë‹¬ì„± |
| **íŒŒì¼ í¬ê¸°** | < 500KB | 378KB | âœ… ë‹¬ì„± |
| **ë“œë¡œìš°ì½œ** | < 1,000 | 512 | âœ… ë‹¬ì„± |

---

## ğŸ¯ í•µì‹¬ êµí›ˆ

### ì„±ê³µí•œ ìµœì í™” ì „ëµ

1. **ë¹Œë“œ íƒ€ì„ ì „ì²˜ë¦¬ (HGM)**
   - ë¸Œë¼ìš°ì € ë¶€ë‹´ì„ ë¹Œë“œ ì‹œê°„ìœ¼ë¡œ ì´ë™
   - ì‚¬ìš©ì ê²½í—˜ ê·¹ì  ê°œì„ 

2. **ë“œë¡œìš°ì½œ ë³‘í•©**
   - GPU ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”
   - ë™ì  ê¸°ëŠ¥ ë³´ì¡´ (êµ­ê°€ë³„ ì œì–´ ê°€ëŠ¥)

3. **ì°¨ì› ì¶•ì†Œ (3D â†’ 2D)**
   - ë³µì¡í•œ 3D ë ˆì´ìºìŠ¤íŠ¸ íšŒí”¼
   - 2D ê³µê°„ ê²€ìƒ‰ + Point-in-Polygon í™œìš©

4. **ê´€ì‹¬ì‚¬ ë¶„ë¦¬**
   - Globe: ìƒí˜¸ì‘ìš© ë‹´ë‹¹
   - RegionFeature: ë Œë”ë§ ë‹´ë‹¹
   - ëª…í™•í•œ ì±…ì„ ë¶„ë¦¬ë¡œ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ

### í•µì‹¬ ì›ì¹™

1. **ì¸¡ì • ìš°ì„ **: ì¶”ì¸¡ì´ ì•„ë‹Œ í”„ë¡œíŒŒì¼ë§ ê¸°ë°˜ ìµœì í™”
2. **ë³‘ëª© ì§‘ì¤‘**: ê°€ì¥ í° ë¬¸ì œë¶€í„° í•´ê²°
3. **íŠ¸ë ˆì´ë“œì˜¤í”„ ê³ ë ¤**: ì„±ëŠ¥ vs ê¸°ëŠ¥ ê· í˜•
4. **ë‹¨ìˆœí•¨ ì¶”êµ¬**: ë³µì¡í•œ í•´ê²°ì±…ë³´ë‹¤ ê°„ê²°í•œ ì„¤ê³„
