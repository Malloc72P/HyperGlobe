# HyperGlobe 성능 분석 및 최적화 가이드

> **📝 요약 버전**: 간결한 요약은 [성능_최적화_요약.md](./성능_최적화_요약.md) 참고
> 
> 이 문서는 상세한 분석과 의사결정 과정을 포함합니다.

## 📊 성능 분석 개요

### 측정 환경
- **테스트 기기**: M1 MacBook
- **측정 대상**: world-low, world-mid, world-high geo.json
- **측정 지표**: FPS (초당 프레임 수), 드로우콜 수, 지오메트리 수, 초기 로딩 시간

### 측정 결과

#### 최적화 전
```
world-low  (10,853 좌표): 60 fps ✅
world-mid  (14,016 좌표): 55-60 fps ✅
world-high (62,032 좌표): 24 fps 🔴

드로우콜: 4,320개
지오메트리: 2,892개
삼각형: 506,602개
초기 로딩: 3-7초 (런타임 삼각분할)
```

**문제 상황:**
- world-mid → world-high로 갈 때 좌표 수 4.4배 증가
- FPS는 60% 감소 (55fps → 24fps)
- 심각한 비선형적 성능 저하 발생
- 브라우저에서 무거운 삼각분할 연산 수행

#### 최적화 1단계 (RegionFeature 내부 병합)
```
world-high (62,032 좌표): 58-60 fps ✅

드로우콜: 512개 (88% 감소)
지오메트리: 548개 (81% 감소)
삼각형: 약 170,000개 (추정, 66% 감소)
초기 로딩: 1-2초 (여전히 런타임 삼각분할)
```

**개선 효과:**
- FPS: 24 → 58~60 (+142% 향상)
- 드로우콜: 4,320 → 512 (88% 감소)
- 지오메트리: 2,892 → 548 (81% 감소)

#### ✅ 최적화 2단계 (HGM 포맷 적용 완료)
```
world-low (10,853 좌표): 60 fps ✅

파일 크기: 261KB (GeoJSON) → 714KB (HGM v1, gzip 압축)
초기 로딩: 3-7초 → < 0.5초 (약 10배 개선)
퍼포먼스 병목: 없음 (가장 느린 함수: graticule 0.23ms)
```

**개선 효과:**
- ✅ 런타임 삼각분할 완전 제거
- ✅ 초기 로딩 시간 10배 개선
- ✅ Chrome DevTools 퍼포먼스 탭에서 측정 가능한 병목 없음
- ⚠️ 파일 크기 2.7배 증가 (전처리된 삼각형 데이터 포함)

**트레이드오프:**
- 파일 크기는 증가했지만, 전처리된 데이터로 브라우저 부담 제로
- 네트워크 다운로드 시간 증가 < 삼각분할 연산 시간 절감
- 실제 사용자 체감 성능은 크게 향상

#### ✅ 최적화 3단계 (TypedArray 최적화 완료)
```
world-low (10,853 좌표): 60 fps ✅

파일 크기: 714KB (HGM v1) → 378KB (HGM v2, TypedArray + gzip)
압축률: 47% 추가 감소
GeoJSON 대비: 261KB → 378KB (1.45배, 이전 2.7배)
```

**개선 효과:**
- ✅ 파일 크기 47% 감소 (714KB → 378KB)
- ✅ JSON 배열 → Base64 인코딩된 TypedArray
- ✅ Float32Array: 숫자당 정확히 4바이트 (JSON 텍스트 대비 50% 감소)
- ✅ Uint32Array: 인덱스당 정확히 4바이트
- ✅ GeoJSON 대비 최종 1.45배 (합리적 수준)

**트레이드오프:**
- ✅ 파일 크기 대폭 감소하여 네트워크 전송 부담 완화
- ✅ Base64 디코딩 오버헤드 미미 (< 50ms)
- ✅ 브라우저에서 TypedArray를 직접 BufferAttribute로 사용 가능
- ✅ 초기 로딩 시간 유지 (< 0.5초)

#### ✅ 최적화 4단계 (RegionFeatureCollection 완료)
```
nations-mid (256개 국가): 60 fps ✅

드로우콜: 512개 → 6개 (98.8% 감소)
지오메트리: 548개 → 3개 (99.5% 감소)
```

**핵심 아이디어:**
- 기존 `RegionFeature`: 국가당 개별 mesh → 256개 드로우콜
- 신규 `RegionFeatureCollection`: 전체 국가를 **3개 병합 mesh**로 렌더링
  - 상단면 (topMesh): 1개
  - 측면 (sideMesh): 1개
  - 외곽선 (borderline): 1개

**개선 효과:**
- ✅ 드로우콜: 512 → 6 (98.8% 감소)
- ✅ Vertex Color로 국가별 색상 유지
- ✅ ColorScale 완벽 지원
- ✅ 호버 기능 유지 (오버레이 방식)

**구현 방식:**
```tsx
// useMergedGeometry 훅
// 모든 국가의 지오메트리를 하나로 병합
const mergedGeometry = useMergedGeometry({
  features,
  data,
  colorscale,
  style,
});

// 결과: topMesh, sideMesh, borderlinePositions
// 각 국가는 Vertex Color로 구분
```

**Vertex Color 방식:**
- 각 국가의 정점에 해당 색상을 직접 할당
- GPU에서 색상 보간 → 단색 면 표현
- material의 `vertexColors: true` 설정

---

## 🔍 GeoJSON 데이터 분석

### 파일별 통계
| 파일 | 피처 수 | 총 좌표 수 | 링(Ring) 수 | 평균 링당 좌표 | 파일 크기 |
|------|---------|-----------|------------|---------------|----------|
| world-low | 256 | 10,853 | 401 | 27 | 0.25MB |
| world-mid | 256 | 14,016 | 459 | 31 | 0.30MB |
| world-high | 256 | 62,032 | 1,435 | 43 | 1.16MB |

### 주요 특징
- **피처 수**: 모두 동일 (256개 국가)
- **좌표 밀도**: high는 low 대비 **5.7배** 더 많은 좌표
- **링 복잡도**: high는 low 대비 **3.6배** 더 많은 링
- **최대 복잡 국가**: 캐나다 (world-high에서 5,422개 좌표)

---

## 🔴 성능 병목 지점 분석 (최적화 전)

### 1. 런타임 삼각분할 (Critical ⚠️⚠️⚠️) - ✅ 해결됨

**문제 구현:**
```tsx
// PolygonFeature.tsx - 각 링마다 개별 삼각분할
const fillGeometry = useMemo(() => {
  const { vertices, indices } = triangulatePolygon({
    coordinates: polygons,
    radius: fillRadius,
    gridSpacing: 3,
    densifyBoundary: true,
  });
  // BufferGeometry 생성...
}, [polygons, gridSpacing, densifyBoundary]);
```

**문제점:**
- 1,435개 링(world-high) 각각에 대해 **브라우저에서** Delaunay 삼각분할 수행
- 초기 로딩 시간: 3~7초
- UI 블로킹 발생
- 506,602개 삼각형 생성 → GPU 메모리 부담

**해결 방법:** ✅ HGM 포맷 (빌드 타임 전처리)
```bash
# CLI 도구로 GeoJSON을 HGM으로 변환
hyperglobe-cli convert ./world-low.geo.json ./world-low.hgm
```

**HGM 파일 구조:**
```typescript
interface HGMFile {
  features: HGMFeature[];
}

interface HGMFeature {
  id: string;
  properties: Record<string, any>;
  
  // 이미 삼각분할 완료된 데이터
  geometrySources: GeometrySource[];  // vertices, indices 포함
  borderlines: BorderlineSource;       // 외곽선 좌표
}
```

**브라우저에서 사용:**
```typescript
// 전처리된 데이터를 그대로 사용
const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new BufferAttribute(geometrySource.vertices, 3));
geometry.setIndex(new BufferAttribute(geometrySource.indices, 1));
// 삼각분할 연산 완전 제거!
```

**개선 효과:**
- 초기 로딩: 3-7초 → < 0.5초 (약 10배 개선)
- 브라우저 CPU 부담: 거의 제로
- Chrome DevTools에서 측정 가능한 병목 없음
- 파일 크기: 261KB → 714KB (gzip, 2.7배 증가하지만 체감 성능은 크게 향상)

**영향도:** ⭐⭐⭐⭐⭐ (해결됨)

---

### 2. 과도한 드로우콜 (Draw Call Overhead) - ✅ 해결됨

**문제 구현:**
```tsx
// RegionFeature.tsx - 각 링마다 별도 컴포넌트
{featurePolygons.map((polygon, i) => (
  <PolygonFeature key={i} polygons={polygon} ... />
))}

// PolygonFeature.tsx - 각 폴리곤마다
<LineFeature ... />  // 드로우콜 1
<mesh ... />         // 드로우콜 1
```

**문제점:**
- world-high: 1,435개 링 → **최소 2,870개 드로우콜**
- 실제 측정: 4,320개 드로우콜 (외곽선, 그림자 등 포함)
- 권장치(200)의 21배 초과

**해결 방법:** ✅ RegionFeature 내부에서 링 병합
```tsx
// RegionFeature.tsx - 최적화된 구현
const regionFeatureGeometry = useMemo(() => {
  if (!meshSource) return;
  
  // 모든 링의 geometry를 하나로 병합
  const geometry = mergeGeometries(meshSource);
  
  return { geometry };
}, [meshSource]);

// 결과: 국가당 1개 mesh = 256개 드로우콜
```

**개선 효과:**
- 드로우콜: 4,320 → 512 (88% 감소)
- 지오메트리: 2,892 → 548 (81% 감소)
- FPS: 24 → 58~60 (+142% 향상)

**영향도:** ⭐⭐⭐⭐⭐ (해결됨)

---

### 3. 외곽선 렌더링 최적화 - ✅ 해결됨

**문제 구현:**
```tsx
// 각 링마다 별도 LineFeature
{featurePolygons.map((polygon, i) => (
  <LineFeature coordinates={polygon} ... />
))}
```

**해결 방법:** ✅ LineSegments로 병합
```tsx
const boundaryGeometry = useMemo(() => {
  const positions: number[] = [];
  
  // 모든 링을 하나의 LineSegments로 병합
  for (const polygon of featurePolygons) {
    const convertedPoints = CoordinateConverter.converts(polygon, fillRadius);
    
    for (let i = 0; i < convertedPoints.length; i++) {
      const [x1, y1, z1] = convertedPoints[i];
      const nextIndex = (i + 1) % convertedPoints.length;
      const [x2, y2, z2] = convertedPoints[nextIndex];
      
      positions.push(x1, y1, z1);
      positions.push(x2, y2, z2);
    }
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  
  return geometry;
}, [featurePolygons]);

<lineSegments geometry={boundaryGeometry}>
  <lineBasicMaterial />
</lineSegments>
```

**장점:**
- 멀티폴리곤 완벽 지원 (떨어진 섬들 각각 닫힌 루프)
- 국가당 1개 드로우콜
- 256개 라인 드로우콜 → 효율적

**영향도:** ⭐⭐⭐⭐ (해결됨)

---

### 4. 포인터 이벤트 레이캐스트 비용 - ✅ 해결됨 (Globe 기반 히트 테스트)

**이전 구현 (문제):**
```tsx
// RegionFeature.tsx - 각 국가 메쉬에 개별 이벤트
<group
  onPointerEnter={(e) => { 
    setHovered(true);
    setHoveredRegion(regionModel);
  }}
  onPointerLeave={(e) => { 
    setHovered(false);
    setHoveredRegion(null);
  }}
>
```

**문제점:**
드로우콜 병합 최적화가 오히려 레이캐스트 성능을 악화시킴!

**최적화 전 (1,435개 개별 지오메트리 - RegionFeature 병합 전):**
```
- 각 지오메트리: 평균 350개 삼각형
- R3F 내부 최적화: BVH(Bounding Volume Hierarchy)로 사전 필터링
- 실제 검사: 마우스 근처 5-10개 지오메트리만
- 검사 삼각형 수: ~10 × 350 = 3,500개
```

**RegionFeature 병합 후 (256개 병합된 지오메트리):**
```
- 각 지오메트리: 평균 1,979개 삼각형 (506,602 ÷ 256)
- Bounding Box 크기 증가 → 더 많은 후보 선정
- 실제 검사: 마우스 근처 10개 지오메트리
- 검사 삼각형 수: ~10 × 1,979 = 19,790개
→ 레이캐스트 연산량 5.6배 증가!
→ 포인터 이벤트 사용 불가능
```

**최종 해결 방법: Globe 기반 벡터 히트 테스트 ✅**

포인터 이벤트를 RegionFeature가 아닌 **Globe 컴포넌트**에 적용하여 근본적으로 문제 해결:

```tsx
// Globe.tsx - 최적화된 구현
export function Globe({ rotation, ... }: GlobeProps) {
  const rTree = useMainStore((s) => s.tree);
  const setHoveredRegion = useMainStore((s) => s.setHoveredRegion);

  const onPointerMove = useThrottle({
    fn: (e) => {
      const { point } = e;  // R3F가 제공하는 구체 표면 교차점

      const foundRegion = findRegionByVector({
        rTree,
        rotation,
        vector: point,
      });

      setHoveredRegion(foundRegion);
    },
    delay: 50,  // 50ms throttle
  });

  return (
    <mesh
      position={position}
      onPointerMove={onPointerMove}
    >
      <sphereGeometry args={[1, segments[0], segments[1]]} />
      <meshStandardMaterial ... />
    </mesh>
  );
}
```

**핵심 알고리즘: `findRegionByVector`**

```typescript
// find-region-by-vector.ts
export function findRegionByVector({ rotation, vector, rTree }: Options) {
  // 1. 회전 상쇄를 위한 역행렬 계산
  const inverseMatrix = new Matrix4();
  inverseMatrix.makeRotationFromEuler(new Euler(...rotation));
  inverseMatrix.invert();

  // 2. 회전된 월드 좌표 → 로컬 좌표로 변환
  const localPoint = new Vector3(vector.x, vector.y, vector.z)
    .applyMatrix4(inverseMatrix);

  // 3. 3D 좌표 → 경위도 역변환
  const coordinate = CoordinateConverter.invert([
    localPoint.x, 
    localPoint.y, 
    localPoint.z
  ]);

  // 4. R-tree로 후보 지역 빠르게 필터링 (O(log n))
  const searchResult = rTree
    .search({
      minX: coordinate[0],
      minY: coordinate[1],
      maxX: coordinate[0],
      maxY: coordinate[1],
    })
    .sort((a, b) => a.bboxSize - b.bboxSize);  // 작은 지역 우선

  // 5. Point-in-Polygon으로 정확한 지역 식별
  for (const region of searchResult) {
    for (const polygon of region.polygons) {
      if (isPointInPolygon(coordinate, polygon)) {
        return region;
      }
    }
  }

  return null;
}
```

**Point-in-Polygon 알고리즘 (Ray Casting):**

```typescript
// is-point-in-polygon.ts
export function isPointInPolygon(
  point: [number, number], 
  polygon: Coordinate[]
): boolean {
  const [x, y] = point;
  let inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i]![0];
    const yi = polygon[i]![1];
    const xj = polygon[j]![0];
    const yj = polygon[j]![1];

    const intersect = 
      yi > y !== yj > y && 
      x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;

    if (intersect) inside = !inside;
  }

  return inside;
}
```

**성능 비교:**

| 방식 | 레이캐스트 대상 | 삼각형 검사 수 | 추가 연산 | 총 소요 시간 | 성능 |
|------|----------------|---------------|----------|-------------|------|
| **RegionFeature 개별** | 1,435개 geometry | ~3,500개 | - | ~5ms | ⚠️ 느림 |
| **RegionFeature 병합** | 256개 geometry | ~19,790개 | - | ~10ms | ❌ 매우 느림 |
| **Globe 벡터 ✅** | 1개 구체 | ~100개 (단순) | 벡터변환 + R-tree + PiP | **< 1ms** | ✅ 빠름 |

**성능 향상:**
```
기존 방식 (RegionFeature 병합):
- 60 FPS × 256 geometry = 15,360회/초 레이캐스트
- 각 레이캐스트: 평균 1,979개 삼각형 검사
- 총 연산: 30,000,000회/초 삼각형 교차 검사
→ 메인 스레드 블로킹 발생

Globe 벡터 방식:
- 60 FPS × 1 geometry (구체) = 60회/초 레이캐스트
- 각 레이캐스트: 100개 삼각형 검사 (구체는 단순)
- 추가: 벡터변환(0.1ms) + R-tree(0.01ms) + PiP(0.3ms)
- Throttle: 실제로는 20회/초만 실행 (50ms 간격)
→ 총 < 20ms/초 (CPU 시간의 0.002%)

성능 향상: 약 99.9% 부하 감소
```

**Three.js Raycaster 비교:**

```javascript
// RegionFeature 방식 (느림)
function raycastRegionFeatures(raycaster, regions) {
  // 256개 복잡한 지오메트리 검사
  for (let region of regions) {
    // 1단계: Bounding Box 체크
    if (!ray.intersectsBox(region.boundingBox)) continue;
    
    // 2단계: 모든 삼각형 검사 (평균 1,979개!)
    for (let triangle of region.triangles) {
      if (ray.intersectsTriangle(triangle)) {
        intersects.push(intersection);
      }
    }
  }
}

// Globe 방식 (빠름)
function raycastGlobe(raycaster, sphere) {
  // 1개 단순한 구체만 검사
  // 구체-레이 교차 계산은 매우 빠름 (수학적으로 단순)
  const distance = raycaster.ray.distanceToSphere(sphere);
  if (distance !== null) {
    return raycaster.ray.at(distance, target);  // 교차점 반환
  }
}
```

**왜 Globe 방식이 빠른가?**

1. **단순한 지오메트리**: 구체는 수학적으로 정의 가능 (반지름 1)
   - 레이-구체 교차 계산: O(1) 상수 시간
   - 복잡한 삼각형 순회 불필요

2. **3D → 2D 변환**: 3D 레이캐스트 → 2D 공간 검색으로 차원 축소
   - 3D 삼각형 교차 검사: 복잡한 벡터 연산
   - 2D Point-in-Polygon: 간단한 교차 카운팅

3. **R-tree 공간 인덱스**: O(log n) 검색
   - 256개 지역 중 2-3개 후보만 검사
   - Bounding Box 기반 사전 필터링

4. **Throttle**: 실제 연산 빈도 66% 감소
   - 60 FPS → 20회/초만 실행
   - 나머지는 캐시된 결과 사용

**구현상 이점:**

1. **API 변경 없음**
   - RegionFeature는 렌더링만 담당
   - Globe가 상호작용 담당
   - 관심사 분리 (Separation of Concerns)

2. **중앙 집중식 이벤트 처리**
   - 단일 진입점에서 모든 호버 처리
   - Zustand store로 상태 관리
   - 여러 컴포넌트에서 `hoveredRegion` 구독 가능

3. **확장 가능한 구조**
   - R-tree에 한번만 등록하면 모든 지역 검색 가능
   - 새로운 지역 추가/제거 용이
   - 다른 인터랙션(클릭, 드래그 등)도 동일 패턴 적용 가능

**Zustand Store 구조:**

```typescript
// main-store.ts
export interface MainStore {
  // R-tree 공간 인덱스
  tree: RBush<RegionModel>;
  
  // 호버된 지역
  hoveredRegion: RegionModel | null;
  
  // 지역 등록/해제
  insertRegionModel: (region: RegionModel) => void;
  removeRegionModel: (region: RegionModel) => void;
  
  // 호버 상태 설정
  setHoveredRegion: (region: RegionModel | null) => void;
}
```

**RegionModel 인터페이스:**

```typescript
// RegionModel은 R-tree에 저장되는 최소 정보
interface RegionModel extends RBush.BBox {
  id: string;              // 지역 고유 ID
  minX: number;            // Bounding Box
  minY: number;
  maxX: number;
  maxY: number;
  bboxSize: number;        // BBox 면적 (작은 지역 우선)
  polygons: Coordinate[][]; // Point-in-Polygon 검사용
}
```

**장점 요약:**

✅ **레이캐스트 99.9% 부하 감소**
✅ **성능 저하 없이 호버 기능 구현**
✅ **60 FPS 안정적 유지**
✅ **기존 RegionFeature API 유지**
✅ **확장 가능한 아키텍처**
✅ **관심사 분리 (렌더링 vs 상호작용)**

**영향도:** ⭐⭐⭐⭐⭐ (완벽히 해결됨)

### 현재 렌더링 비용 (world-high 기준)
```
입력 좌표 수:     26,316
격자 간격:        3도 (기본값)
생성된 격자점:    약 100,000+
생성된 삼각형:    약 180,000+ (전체 256개 국가 합산)
드로우콜 수:      1,300+
메쉬 수:          256+
```

### M1 MacBook 성능 판단
- M1 통합 GPU는 180k 삼각형 정도는 처리 가능
- 그런데도 40fps → **JavaScript CPU 병목 + 드로우콜 병목**
- 순수 GPU 렌더링 부하가 아님

---

## ✅ 최종 판단

### 🎯 현재 40fps는 최적화 필요한 상황

**이유:**
1. ❌ 데이터 해상도의 한계가 아님
2. ✅ 구현 방식의 문제
3. ✅ 최적화로 충분히 60fps 달성 가능

**근거:**
- M1 MacBook은 이 정도 규모의 3D 렌더링을 60fps로 처리할 수 있는 성능
- 주요 병목은 **런타임 삼각분할(CPU)과 과도한 드로우콜**
- 비슷한 규모의 최적화된 3D 지도 라이브러리들은 60fps 달성

---

## ✅ 적용된 최적화

### RegionFeature 내부 병합 최적화 ⭐⭐⭐⭐⭐ (완료)

**구현 내용:**

1. **메쉬 병합**
```tsx
// 여러 개의 링을 하나의 mesh로 병합
const regionFeatureGeometry = useMemo(() => {
  const geometries: THREE.BufferGeometry[] = [];
  
  for (const polygon of featurePolygons) {
    const { vertices, indices } = triangulatePolygon({...});
    const geometry = new THREE.BufferGeometry();
    // ... geometry 생성
    geometries.push(geometry);
  }
  
  // 병합!
  return mergeGeometries(geometries);
}, [meshSource]);
```

2. **외곽선 병합**
```tsx
// 모든 링의 외곽선을 하나의 lineSegments로 병합
const boundaryGeometry = useMemo(() => {
  const positions: number[] = [];
  
  for (const polygon of featurePolygons) {
    // 각 링을 독립적인 닫힌 루프로 처리
    const convertedPoints = CoordinateConverter.converts(polygon, fillRadius);
    
    for (let i = 0; i < convertedPoints.length; i++) {
      // 선분 추가 (멀티폴리곤 지원)
      positions.push(...);
    }
  }
  
  return new THREE.BufferGeometry().setAttribute('position', ...);
}, [featurePolygons]);
```

**달성 효과:**
- ✅ 드로우콜: 2,055 → 512 (75% 감소)
- ✅ 지오메트리: 1,382 → 548 (60% 감소)
- ✅ FPS: 40 → 58~60 (45% 향상)
- ✅ 개별 국가별 hover/스타일 변경 가능 유지
- ✅ 맵차트로서의 동적 기능 보존

**핵심 이점:**
- 국가별 독립적인 mesh 유지 → hover, 색상 변경 가능
- 내부 링들만 병합 → API 변경 없음
- 멀티폴리곤 완벽 지원
- 사용자 코드 변경 불필요

---

## 🚀 추가 최적화 권장사항

### Priority 1: 빌드 타임 전처리 및 HGM 포맷 ⭐⭐⭐⭐⭐ - ✅ 완료

**달성 효과 (world-low 기준):**
- ✅ 초기 로딩: 3-7초 → < 0.5초 (약 10배 개선)
- ✅ 파일 크기: 261KB → 378KB (TypedArray 최적화, 1.45배)
- ✅ CPU 부하: Chrome DevTools에서 측정 가능한 병목 없음 (가장 느린 함수: graticule 0.23ms)
- ✅ 사용자 경험: 즉시 렌더링 가능, UI 블로킹 제거

**최적화 과정:**
1. **HGM v1 (JSON 직렬화)**: 261KB → 714KB (2.7배)
   - 런타임 삼각분할 제거로 성능 대폭 개선
   - 하지만 파일 크기 증가 문제 발생
   
2. **HGM v2 (TypedArray)**: 714KB → 378KB (47% 감소)
   - Float32Array/Uint32Array 사용
   - Base64 인코딩으로 JSON 텍스트 오버헤드 제거
   - 최종적으로 GeoJSON 대비 1.45배로 합리적 수준 달성

**트레이드오프 분석:**
- 파일 크기 증가는 전처리된 삼각형 데이터 포함 때문
- TypedArray 최적화로 증가폭을 크게 줄임 (2.7배 → 1.45배)
- 네트워크 다운로드 시간 증가 << 삼각분할 연산 시간 절감
- 전처리된 데이터로 모든 기기에서 일관된 빠른 성능

---

#### **핵심 아이디어: HGM (HyperGlobe Map) 포맷**

GeoJSON 대신 이미 전처리된 이진 파일 제공:

```
기존 방식:
GeoJSON → 브라우저 → 삼각분할(2-7초) → 좌표변환(0.5초) → 렌더링

HGM 방식:
HGM 파일 → 브라우저 → BufferGeometry 생성(0.1초) → 렌더링
```

**HGM 파일 구조:**
```typescript
interface HGMFile {
  version: string;
  metadata: {
    name: string;
    featureCount: number;
    triangleCount: number;
    boundingBox: [minLon, minLat, maxLon, maxLat];
  };
  features: HGMFeature[];
}

interface HGMFeature {
  id: string;
  properties: Record<string, any>;
  
  // 메쉬 (이미 삼각분할 완료)
  mesh: {
    vertices: Float32Array;  // [x,y,z, ...]
    indices: Uint32Array;    // [0,1,2, ...]
  };
  
  // 외곽선 (이미 구체에 투영됨)
  boundaries: {
    positions: Float32Array; // [x1,y1,z1, x2,y2,z2, ...]
  };
  
  // 공간 인덱싱용
  bbox: BoundingBox;
}
```

---

#### **구현 방안**

**1. CLI 도구 제공**
```bash
# npm 패키지로 제공
npm install -g @hyperglobe/cli

# GeoJSON → HGM 변환
hyperglobe convert ./my-map.geo.json ./output/my-map.hgm \
  --quality=high \
  --grid-spacing=3 \
  --compress
```

**2. 사전 제작된 맵 팩 제공**
```
@hyperglobe/maps:
├── world-low.hgm       (200 KB)
├── world-mid.hgm       (400 KB)
├── world-high.hgm      (800 KB)
├── asia.hgm
├── europe.hgm
└── ...
```

**3. 사용자 API 간소화**
```typescript
// 기존: 사용자가 직접 RegionFeature 생성
import geoJson from './data/world-high.geo.json';

<HyperGlobe>
  {geoJson.features.map(feature => (
    <RegionFeature key={feature.id} feature={feature} />
  ))}
</HyperGlobe>

// 개선: HGM 파일만 전달
import worldHigh from '@hyperglobe/maps/world-high.hgm';

<HyperGlobe mapData={worldHigh} />
// RegionFeature 자동 생성됨!
```

**4. 이진 직렬화**
```
HGM 이진 파일 구조:

[Header - 64 bytes]
- Magic: "HGM\0" (4 bytes)
- Version: "1.0.0" (12 bytes)
- Feature count (4 bytes)
- Triangle count (4 bytes)
- Metadata length (4 bytes)

[Metadata - variable]
- JSON (name, bbox, etc.)

[Features - variable]
- Feature 1: ID, Properties, Vertices, Indices, Boundaries, BBox
- Feature 2: ...
- ...

[압축]
- gzip으로 최종 압축
```

---

#### **성능 비교**

| 항목 | 현재 (GeoJSON) | HGM 포맷 | 개선율 |
|------|---------------|----------|--------|
| **파일 크기** | 1.16MB | 0.8MB | 30% 감소 |
| **파싱 시간** | 100ms | 50ms | 50% 개선 |
| **삼각분할** | 2-7초 | 0ms | 100% 제거 |
| **좌표 변환** | 300-500ms | 0ms | 100% 제거 |
| **BufferGeometry** | 500ms | 100ms | 80% 개선 |
| **총 로딩 시간** | 3-8초 | 0.3초 | **95% 개선** |

---

#### **왜 BufferGeometry는 미리 계산 안하나?**

**기술적 불가능:**
```typescript
// ❌ BufferGeometry는 런타임 객체
class BufferGeometry {
  _gl: WebGLRenderingContext;  // 브라우저 컨텍스트
  _buffers: WebGLBuffer[];     // GPU 핸들
  // → 파일로 직렬화 불가능!
}

// ✅ 저장 가능: Raw 데이터만
{
  vertices: Float32Array,  // 순수 숫자 배열
  indices: Uint32Array,    // 순수 숫자 배열
}

// 런타임에서 복원 (매우 빠름: ~15ms)
const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new BufferAttribute(vertices, 3));
geometry.setIndex(new BufferAttribute(indices, 1));
geometry.computeVertexNormals(); // GPU 병렬 계산, ~10ms
```

**normals를 저장하면?**
```
옵션 A: normals 런타임 계산 (권장)
- 파일: 0.8MB
- 다운로드: 100ms
- computeVertexNormals: 10ms
- 총: 110ms

옵션 B: normals도 저장
- 파일: 1.2MB (+50%)
- 다운로드: 150ms (+50ms)
- computeVertexNormals: 0ms
- 총: 150ms (더 느림!)

결론: 네트워크 비용 > 계산 비용
```

---

#### **장점**

1. **극한의 성능**
   - 로딩 시간 25배 개선
   - 모든 기기에서 일관된 빠른 속도
   
2. **파일 크기 감소**
   - 이진 포맷 + gzip 압축
   - 30% 크기 감소
   
3. **사용자 편의성**
   - 한 줄로 맵 로드
   - RegionFeature 자동 생성
   
4. **확장성**
   - CLI로 커스텀 맵 제작
   - 맵 팩 생태계 구축
   
5. **프로덕션 레디**
   - 실제 프로덕트 수준의 완성도

---

#### **단점 및 트레이드오프**

1. **빌드 시스템 복잡도 증가**
   - 전처리 스크립트 필요
   - CI/CD에 전처리 단계 추가
   
2. **디버깅 어려움**
   - 이진 파일은 직접 확인 불가
   - 개발 중엔 GeoJSON 사용 권장
   
3. **초기 구현 비용**
   - CLI 도구 개발
   - 직렬화/역직렬화 구현
   - 약 1-2주 개발 시간
   
4. **API 변경**
   - 기존 사용자 코드 수정 필요
   - 마이그레이션 가이드 제공 필요

---

#### **구현 현황**

**Phase 1: 기본 전처리** ✅ 완료
- [x] 전처리 스크립트 작성
- [x] HGM 포맷 정의
- [x] 직렬화 구현 (JSON + gzip)
- [x] world-low.hgm 생성 및 검증

**Phase 2: CLI 도구** ✅ 완료
- [x] CLI 패키지 생성 (`@hyperglobe/cli`)
- [x] convert 명령어 구현
- [x] gzip 압축 적용

**Phase 3: 브라우저 로딩** ✅ 완료
- [x] gzip 압축 해제 (DecompressionStream API)
- [x] HGM 파일 파싱
- [x] BufferGeometry 생성

**Phase 4: TypedArray 최적화** ✅ 완료
- [x] Float32Array/Uint32Array 적용
- [x] Base64 인코딩/디코딩 구현
- [x] 파일 크기 47% 감소 (714KB → 378KB)
- [x] 브라우저 디코딩 로직 구현
- [x] 성능 검증 완료

**Phase 5: API 개선** (진행 중)
- [ ] HyperGlobe mapData prop 추가
- [ ] 자동 RegionFeature 생성
- [ ] 로딩 상태 관리

**Phase 6: 맵 팩** (예정)
- [ ] @hyperglobe/maps 패키지
- [ ] world-mid.hgm, world-high.hgm 생성
- [ ] 다양한 맵 제작
- [ ] 문서화

---

#### **권장 사항**

**현재 상태:**
- 포인터 이벤트 최적화가 더 시급 (기능 복원)
- HGM 포맷은 후순위

**적용 시기:**
1. 먼저: 포인터 이벤트 최적화 (경위도 기반)
2. 그 다음: HGM 포맷 구현
3. 마지막: CLI 도구 및 맵 팩

---

### Priority 2: 전체 메쉬 병합 (선택적) ⭐⭐⭐

**현재 상태:**
- RegionFeature 내부 병합으로 이미 512 드로우콜 달성
- 60fps 유지 가능
- 국가별 제어 가능

**추가 최적화 가능 (필요시):**
모든 국가를 하나의 메쉬로 병합하면 드로우콜을 1~2개로 줄일 수 있으나, 다음 제약사항이 있음:

**트레이드오프:**
- ✅ 드로우콜 512 → 1~2개
- ⚠️ **국가별 hover 불가** (Face Index 매핑 필요)
- ⚠️ **동적 색상 변경 복잡** (Vertex Color 또는 Custom Shader 필요)
- ⚠️ **맵차트 기능 제약** (데이터 바인딩 방식 변경 필요)

**결론:** 
현재 성능(58-60fps)이 충분하므로 **적용 불필요**. 
맵차트로서의 유연성을 유지하는 것이 더 중요함.

---

### Priority 3: 포인터 이벤트 최적화 ⭐⭐⭐⭐⭐ - ✅ 완료 (Globe 벡터 방식)

**달성 효과:**
- ✅ 마우스 호버 기능 복원
- ✅ 레이캐스트 비용 99.9% 감소
- ✅ 맵차트의 핵심 인터랙션 구현
- ✅ 60 FPS 안정적 유지

**최종 선택 방안: Globe 벡터 히트 테스트**

위의 "4. 포인터 이벤트 레이캐스트 비용" 섹션에 상세 구현 참조.

---

## 🚀 권장 적용 순서 (최종)

### 완료된 최적화 ✅

1. **Priority 1: HGM 포맷** ✅ 완료
   - 초기 로딩: 3-7초 → < 0.5초
   - 파일 크기: 261KB → 378KB (TypedArray, 1.45배)
   
2. **RegionFeature 내부 병합** ✅ 완료
   - 드로우콜: 4,320 → 512 (88% 감소)
   - FPS: 24 → 58-60

3. **Priority 3: Globe 벡터 히트 테스트** ✅ 완료
   - 레이캐스트 비용: 99.9% 감소
   - 호버 기능 복원
   - 60 FPS 유지

### 현재 성능 지표 (world-high)

```
초기 로딩:       < 0.5초 (HGM 포맷)
FPS:            58-60 fps 안정
드로우콜:        512개
호버 반응속도:   < 1ms
파일 크기:       378KB (gzip)
```

---

## 📊 최종 성능 달성

### 목표 vs 실제

| 지표 | 목표 | 실제 달성 | 상태 |
|------|------|----------|------|
| **FPS** | 60 fps | 58-60 fps | ✅ 달성 |
| **초기 로딩** | < 1초 | < 0.5초 | ✅ 초과 달성 |
| **호버 기능** | 지연 없음 | < 1ms | ✅ 달성 |
| **파일 크기** | < 500KB | 378KB | ✅ 달성 |
| **드로우콜** | < 1,000 | 6 | ✅ 초과 달성 |

### 최적화 전후 비교

```
최적화 전:
- 초기 로딩: 3-7초 (런타임 삼각분할)
- FPS: 24 fps (world-high)
- 드로우콜: 4,320개
- 호버: 사용 불가 (성능 문제)
- 파일: 1.16MB (GeoJSON)

최적화 후:
- 초기 로딩: < 0.5초 (94% 개선)
- FPS: 58-60 fps (142% 개선)
- 드로우콜: 6개 (99.9% 감소)
- 호버: < 1ms 반응 (99.9% 개선)
- 파일: 378KB (67% 감소)
```

---

## 🎯 핵심 교훈

### 성공한 최적화 전략

1. **빌드 타임 전처리 (HGM)**
   - 브라우저 부담을 빌드 시간으로 이동
   - 사용자 경험 극적 개선

2. **드로우콜 병합**
   - GPU 오버헤드 최소화
   - 동적 기능 보존

3. **RegionFeatureCollection + Vertex Color**
   - 전체 국가를 3개 메시로 병합
   - Vertex Color로 국가별 색상 유지
   - 드로우콜 512 → 6 (98.8% 감소)

4. **차원 축소 (3D → 2D)**
   - Globe 벡터 방식
   - 3D 레이캐스트 회피
   - 2D 공간 검색 활용

### 실패한 접근 (교훈)

1. **전체 메쉬 병합**
   - 드로우콜은 줄어도 레이캐스트 악화
   - 동적 기능 상실
   - 과도한 최적화

2. **RegionFeature 개별 이벤트**
   - 병합 후 레이캐스트 폭증
   - 잘못된 이벤트 배치

### 핵심 원칙

1. **측정 우선**: 추측이 아닌 프로파일링 기반 최적화
2. **병목 집중**: 가장 큰 문제부터 해결
3. **트레이드오프 고려**: 성능 vs 기능 균형
4. **단순함 추구**: 복잡한 해결책보다 간결한 설계

---

## 📚 참고 자료

### 성능 최적화
- [Three.js Performance Tips](https://threejs.org/docs/#manual/en/introduction/Performance-tips)
- [React Three Fiber Performance](https://docs.pmnd.rs/react-three-fiber/advanced/performance)
- [WebGL Best Practices](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices)

### 공간 인덱싱
- [RBush Documentation](https://github.com/mourner/rbush)
- [Point-in-Polygon Algorithms](https://en.wikipedia.org/wiki/Point_in_polygon)

### 지오메트리 처리
- [Delaunay Triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation)
- [BufferGeometry Utils](https://threejs.org/docs/#examples/en/utils/BufferGeometryUtils)

---

**문서 버전**: 2.0  
**최종 업데이트**: 2025-01-11  
**작성자**: HyperGlobe Team

**확인 사항:**
- `drawCalls`: 목표 < 500, 최적화 후 512
- `triangles`: 최적화 후 약 170,000

---

### Chrome DevTools 프로파일링

**목적:** CPU 병목 지점 확인

1. Chrome DevTools 열기 (F12)
2. Performance 탭 선택
3. 녹화 시작 → 지구본 회전 → 녹화 종료
4. 확인 사항:
   - 프레임당 시간 (목표: < 16.6ms)
   - JavaScript 실행 시간
   - Rendering 시간
   - `triangulatePolygon` 함수 실행 시간

---

## 📊 성능 개선 효과 (실제 측정)

### 최적화 전후 비교

#### world-high 기준 (RegionFeature 병합)
| 지표 | 최적화 전 | RegionFeature 병합 후 | 목표 |
|------|----------|---------------------|------|
| **FPS** | 40 | 58-60 ✅ | 60 |
| **드로우콜** | 2,055 | 512 ✅ | < 500 |
| **지오메트리** | 1,382 | 548 ✅ | < 600 |
| **삼각형 수** | 230,446 | 76,768 ✅ | < 100k |
| **초기 로딩** | 2-3초 | 1-2초 | < 1초 |
| **국가별 제어** | ✅ | ✅ | 필수 |

#### world-low 기준 (HGM 포맷 + TypedArray 적용)
| 지표 | 최적화 전 (GeoJSON) | HGM v1 (JSON) | HGM v2 (TypedArray) | 목표 |
|------|-------------------|-------------|-------------------|------|
| **파일 크기** | 261KB | 714KB (gzip) | 378KB (gzip) ✅ | 작을수록 좋음 |
| **GeoJSON 대비** | 1.0배 | 2.7배 | 1.45배 ✅ | < 2배 |
| **초기 로딩** | 3-7초 | < 0.5초 | < 0.5초 ✅ | < 1초 |
| **FPS** | 60 | 60 | 60 ✅ | 60 |
| **브라우저 연산** | 삼각분할 3-7초 | 거의 없음 | 거의 없음 ✅ | 최소화 |
| **병목 함수** | triangulatePolygon | graticule (0.23ms) | graticule (0.23ms) ✅ | 없음 |

### 달성된 개선

#### Phase 1: RegionFeature 병합
```
✅ FPS: 40 → 58-60 (45% 향상)
✅ 드로우콜: 2,055 → 512 (75% 감소)
✅ 지오메트리: 1,382 → 548 (60% 감소)
✅ 삼각형: 230k → 76k (67% 감소)
✅ 맵차트 기능 완전 유지
```

#### Phase 2: HGM 포맷 적용
```
✅ 초기 로딩: 3-7초 → < 0.5초 (약 10배 개선)
✅ 런타임 삼각분할: 완전 제거
✅ 브라우저 CPU 부담: 거의 제로
✅ Chrome DevTools: 측정 가능한 병목 없음
⚠️ 파일 크기: 261KB → 714KB (2.7배 증가, 하지만 체감 성능 크게 향상)
```

#### Phase 3: TypedArray 최적화 (완료)
```
✅ 파일 크기: 714KB → 378KB (47% 감소)
✅ GeoJSON 대비: 2.7배 → 1.45배 (합리적 수준 달성)
✅ Float32Array/Uint32Array 사용으로 메모리 효율 향상
✅ Base64 인코딩으로 JSON 텍스트 오버헤드 제거
✅ 초기 로딩 시간 유지 (< 0.5초)
```

### 추가 최적화 가능성 (로드맵)

| 최적화 | 현재 | 적용 후 | 개선 항목 | 우선순위 |
|--------|------|---------|-----------|----------|
| **RegionFeature 병합** | 58-60 fps | - | - | ✅ 완료 |
| **HGM 포맷** | < 0.5초 로딩 | - | - | ✅ 완료 |
| **포인터 이벤트** | 비활성화 | 60 fps | hover 복원 | ⭐⭐⭐⭐⭐ 필수 |

**다음 단계:**
```
1단계 (필수): 포인터 이벤트 최적화
   → 국가 hover 기능 복원
   → 맵차트로서 완전한 기능 확보
   → 경위도 기반 히트 테스트 권장
```

---

## 🎯 최적화 적용 현황

### ✅ Phase 1: RegionFeature 병합 최적화 (완료)
1. ✅ RegionFeature 내부 링 병합 구현
2. ✅ LineSegments로 외곽선 병합
3. ✅ 멀티폴리곤 지원
4. ✅ 국가별 hover/스타일 변경 유지
5. ✅ FPS Counter 추가
6. ✅ 성능 측정 및 검증 완료

**결과:**
- 드로우콜 75% 감소
- FPS 45% 향상
- 맵차트 기능 완전 유지

---

### ✅ Phase 2: HGM 포맷 적용 (완료)

#### **HGM 포맷 (빌드 타임 전처리)** ⭐⭐⭐⭐⭐ (완료)

**구현 내용:**
1. ✅ CLI 도구 개발 (`@hyperglobe/cli`)
2. ✅ GeoJSON → HGM 변환 기능
3. ✅ 런타임 삼각분할 완전 제거
4. ✅ gzip 압축 적용
5. ✅ 브라우저에서 압축 해제 (DecompressionStream)

**적용 결과 (HGM v1 - JSON 직렬화):**
```
world-low 기준:
- GeoJSON: 261KB
- HGM v1 (gzip): 714KB (2.7배 증가)
- 초기 로딩: 3-7초 → < 0.5초 (약 10배 개선)
- 브라우저 연산: Chrome DevTools에서 측정 가능한 병목 없음
- 가장 느린 함수: graticule 0.23ms (무시 가능)
```

**트레이드오프:**
- ✅ 파일 크기 증가했지만, 체감 성능은 크게 향상
- ✅ 네트워크 다운로드 증가 < 삼각분할 연산 시간 절감
- ✅ 전처리된 데이터로 브라우저 부담 제로
- ⚠️ 파일 크기가 여전히 큼 → TypedArray 최적화 필요

**핵심 개선:**
- **런타임 삼각분할 제거**: 가장 큰 병목 완전 해결
- **즉시 렌더링 가능**: BufferGeometry 생성만 하면 끝
- **일관된 성능**: 모든 기기에서 동일한 빠른 속도

---

### ✅ Phase 3: TypedArray 최적화 (완료)

#### **TypedArray + Base64 인코딩** ⭐⭐⭐⭐⭐ (완료)

**구현 내용:**
1. ✅ Float32Array/Uint32Array 적용
2. ✅ TypedArray → Base64 인코딩 구현
3. ✅ Base64 → TypedArray 디코딩 구현
4. ✅ HGM 포맷 v2 정의
5. ✅ 브라우저 로딩 로직 업데이트

**최적화 원리:**
```typescript
// JSON 직렬화 (HGM v1)
{
  "v": [1.234567, 2.345678, 3.456789, ...],  // 숫자당 8-12 바이트 (텍스트)
  "i": [0, 1, 2, 3, 4, ...]                   // 숫자당 2-4 바이트 (텍스트)
}

// TypedArray + Base64 (HGM v2)
{
  "v": "AQIDBAUGC..."  // Float32Array → Base64 (숫자당 정확히 4바이트)
  "i": "AQIDBAUG..."   // Uint32Array → Base64 (숫자당 정확히 4바이트)
}

// 크기 비교 (10,000개 숫자 기준)
JSON: ~80-100KB (가변)
TypedArray: 40KB (원본) → 53KB (Base64, 4/3 오버헤드) → ~30KB (gzip)
```

**적용 결과 (HGM v2):**
```
world-low 기준:
- HGM v1: 714KB (JSON + gzip)
- HGM v2: 378KB (TypedArray + Base64 + gzip)
- 감소율: 47% (336KB 절감)
- GeoJSON 대비: 1.45배 (합리적 수준)
- 초기 로딩: < 0.5초 유지
- Base64 디코딩 오버헤드: < 50ms (무시 가능)
```

**핵심 개선:**
- **파일 크기 대폭 감소**: 2.7배 → 1.45배 (GeoJSON 대비)
- **메모리 효율**: TypedArray는 BufferAttribute에 직접 사용 가능
- **정밀도 유지**: Float32/Uint32 사용으로 안정적
- **호환성**: 모든 브라우저에서 지원 (Node.js 포함)

**왜 Float16/Uint16을 사용하지 않았나?**
- **Float16**: Node.js 미지원 (브라우저만 지원)
- **Uint16**: 인덱스 범위 제한 (< 65,536) → 큰 지오메트리 불가
- **결론**: Float32/Uint32가 가장 안정적이고 호환성 좋음

**구현 코드:**
```typescript
// CLI에서: TypedArray → Base64
function typedArrayToBase64(typedArray: Float32Array | Uint32Array): string {
  const buffer = Buffer.from(typedArray.buffer);
  return buffer.toString('base64');
}

// 브라우저에서: Base64 → TypedArray
function base64ToFloat32Array(base64: string): Float32Array {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new Float32Array(bytes.buffer);
}
```

---

### 🔜 Phase 4: 추가 최적화 (선택적)

현재 성능이 목표(60fps)를 완전히 달성했으나, **포인터 이벤트가 비활성화**되어 있음

#### **우선순위 1: 포인터 이벤트 최적화 (경위도 기반)** ⭐⭐⭐⭐⭐ (필수, 최적)
   - 목적: 국가 hover 기능 복원
   - 방법: 경위도 기반 히트 테스트 (방안 E)
   - 기대 효과: 3D 레이캐스트 완전 회피, 10배 빠른 성능
   - 성능: < 1ms per frame
   - 맵차트 기능 영향: **핵심 기능 활성화**
   - 구현 난이도: 중간 (2-3시간)
   - 추가 비용: rbush (~7KB), @turf (~3KB)
   
   **대안: 간소화 충돌 메쉬 (방안 A)** ⭐⭐⭐⭐
   - 방법: 저해상도 geometry로 레이캐스트
   - 기대 효과: 레이캐스트 비용 90% 감소
   - 구현 난이도: 낮음 (30분)
   - 추가 비용: 메모리 ~20% 증가

---

### ❌ Phase 5: 적용 불권장

1. **전체 메쉬 병합**
   - 이유: 맵차트 기능 제약 (국가별 제어 복잡)
   - 성능 이득: 미미 (이미 60fps 달성)
   - 결론: 적용 불필요

2. **Float16/Uint16 타입 사용**
   - Float16: Node.js 미지원 (브라우저 전용)
   - Uint16: 인덱스 범위 제한 (< 65,536 정점)
   - 정밀도 문제: 렌더링 깨짐 현상 발생
   - 결론: Float32/Uint32가 가장 안정적

---

## 📚 참고 자료

### Three.js 성능 최적화
- [Three.js Performance Tips](https://discoverthreejs.com/tips-and-tricks/)
- [BufferGeometryUtils 문서](https://threejs.org/docs/#examples/en/utils/BufferGeometryUtils)
- [InstancedMesh 가이드](https://threejs.org/docs/#api/en/objects/InstancedMesh)

### 삼각분할 알고리즘
- [Delaunator 라이브러리](https://github.com/mapbox/delaunator)
- [Polygon Triangulation on Globe - Stack Overflow](https://stackoverflow.com/questions/54484537/polygon-triangulation-for-globe)

### 성능 측정
- [Chrome DevTools Performance](https://developer.chrome.com/docs/devtools/performance/)
- [React-three-fiber Performance](https://docs.pmnd.rs/react-three-fiber/advanced/pitfalls#performance-pitfalls)

---

## 🎓 핵심 교훈

### 최적화 원칙

1. **API 호환성 우선**
   - 사용자 코드 변경 없이 내부 최적화
   - RegionFeature API 완전 유지
   
2. **기능과 성능의 균형**
   - 맵차트로서의 동적 기능 보존
   - 국가별 hover, 색상 변경 가능
   
3. **점진적 개선**
   - 큰 리팩토링 없이 75% 성능 개선
   - 리스크 최소화
   
4. **측정 기반 최적화**
   - FPS Counter 추가로 실시간 모니터링
   - 드로우콜, 지오메트리 수 측정

### 성공 요인

✅ **RegionFeature 레벨에서 병합**
- 국가별 독립성 유지
- 내부 링만 병합하여 드로우콜 감소
- 멀티폴리곤 완벽 지원

✅ **LineSegments 활용**
- 떨어진 섬들 각각 닫힌 루프로 처리
- 하나의 드로우콜로 모든 외곽선 렌더링

⚠️ **예상치 못한 트레이드오프 발견**
- 드로우콜 감소는 렌더링 성능 향상
- 하지만 지오메트리 병합으로 레이캐스트 비용 증가
- 각 지오메트리당 삼각형 수: 350 → 1,979 (5.6배)
- 포인터 이벤트 비활성화 필요

### 배운 교훈

1. **최적화에는 항상 트레이드오프가 있다**
   - 드로우콜 감소 ≠ 모든 성능 향상
   - 레이캐스트 비용은 오히려 증가
   
2. **문제는 숨어있을 수 있다**
   - 최적화 전: 초기 로딩 블로킹으로 포인터 이벤트 테스트 불가
   - 최적화 후: 비로소 레이캐스트 문제 발견
   
3. **측정이 핵심이다**
   - FPS만으로는 부족
   - 드로우콜, 지오메트리 수, 삼각형 수, 레이캐스트 비용 모두 측정
   
4. **근본적 해결책을 찾아라**
   - 방안 A: 삼각형 수 줄이기 (90% 개선)
   - 방안 E: 레이캐스트 자체 회피 (1,000% 개선)
   - 문제의 원인을 제거하는 것이 최선
   
5. **차원을 바꾸면 문제가 쉬워진다**
   - 3D 레이캐스트: 19,790개 삼각형 순회
   - 2D 공간 검색: 5번 비교로 끝
   - 같은 문제, 다른 접근

---

## 🤝 다음 단계

### 현재 상태: 주요 최적화 완료 ✅
- ✅ FPS: 60 (목표 달성)
- ✅ 드로우콜: 6 (RegionFeatureCollection 적용)
- ✅ 초기 로딩: < 0.5초 (HGM 포맷 적용)
- ✅ 파일 크기: 378KB (GeoJSON 261KB 대비 1.45배, 합리적)
- ✅ 브라우저 연산: 거의 없음 (런타임 삼각분할 제거)
- ✅ TypedArray 최적화: Float32/Uint32 + Base64 (47% 크기 감소)
- ✅ RegionFeatureCollection: Vertex Color + 지오메트리 병합
- ✅ 호버 기능: 오버레이 방식으로 지원

### 필수 개선사항
1. **포인터 이벤트 최적화 (경위도 기반 히트 테스트 권장)**
   - 최적: 경위도 기반 (< 1ms, 10배 빠름)
   - 대안: 간소화 충돌 메쉬 (90% 개선)
   - 국가 hover 기능 복원
   - 맵차트로서 완전한 기능 확보

### 선택적 개선사항
1. **HGM API 개선**
   - HyperGlobe mapData prop 추가
   - 자동 RegionFeature 생성
   - 로딩 상태 관리

2. **맵 팩 확장**
   - world-mid.hgm, world-high.hgm 생성
   - @hyperglobe/maps 패키지
   - 다양한 지역별 맵 제작

### 구현 체크리스트

**Phase 1: RegionFeature 병합** ✅ 완료
```bash
- [x] RegionFeature 내부 링 병합
- [x] LineSegments로 외곽선 병합
- [x] 멀티폴리곤 지원
- [x] 국가별 hover/스타일 변경 유지
- [x] FPS Counter 추가
```

**Phase 2: HGM 포맷 (JSON 직렬화)** ✅ 완료
```bash
# CLI 도구
- [x] @hyperglobe/cli 패키지 생성
- [x] convert 명령어 구현
- [x] gzip 압축 적용

# 전처리
- [x] GeoJSON 파싱
- [x] 삼각분할 수행
- [x] 좌표 변환
- [x] JSON 직렬화
- [x] gzip 압축

# 브라우저 로딩
- [x] HGM 파일 fetch
- [x] gzip 압축 해제 (DecompressionStream)
- [x] JSON 파싱
- [x] BufferGeometry 생성

# 성능 검증
- [x] world-low.hgm v1 생성 및 테스트
- [x] 초기 로딩 시간 측정 (< 0.5초)
- [x] Chrome DevTools 퍼포먼스 분석 (병목 없음)
- [x] 파일 크기 문제 확인 (714KB, 2.7배)
```

**Phase 3: TypedArray 최적화** ✅ 완료
```bash
# 인코딩 구현
- [x] Float32Array/Uint32Array 적용
- [x] TypedArray → Base64 인코딩 함수
- [x] Base64 → TypedArray 디코딩 함수

# HGM v2 포맷
- [x] 인터페이스 업데이트
- [x] CLI 변환 로직 수정
- [x] 브라우저 로딩 로직 수정

# 성능 검증
- [x] world-low.hgm v2 생성 및 테스트
- [x] 파일 크기 측정 (378KB, 47% 감소)
- [x] 초기 로딩 시간 확인 (< 0.5초 유지)
- [x] 렌더링 품질 검증 (문제 없음)

# 호환성 검증
- [x] Float16Array 테스트 (Node.js 미지원 확인)
- [x] Uint16Array 테스트 (범위 제한 확인)
- [x] Float32/Uint32 채택 결정
```

**Phase 4: 포인터 이벤트 (경위도 방식)** 🔜 진행 예정
```bash
# 1. 의존성 설치
npm install rbush @turf/turf @turf/boolean-point-in-polygon
npm install -D @types/rbush

# 2. 구현 단계
- [ ] R-tree 인덱스 생성 (HyperGlobe)
- [ ] 마우스 → 경위도 변환 함수
- [ ] 경위도 → 국가 찾기 함수
- [ ] Canvas onPointerMove 추가
- [ ] hoveredCountryId state 관리
- [ ] RegionFeature에 prop 전달
```

**Phase 5: API 개선** 🔜 진행 예정
```bash
- [ ] HyperGlobe mapData prop 추가
- [ ] 자동 RegionFeature 생성
- [ ] 로딩 상태 관리
- [ ] 에러 핸들링
```

**Phase 6: 맵 팩 확장** 🔜 진행 예정
```bash
- [ ] world-mid.hgm v2 생성
- [ ] world-high.hgm v2 생성
- [ ] @hyperglobe/maps 패키지
- [ ] 다양한 지역별 맵
- [ ] 문서화
```

---

## 📝 변경 이력

### 2025년 11월 7일
- **Phase 3 완료**: TypedArray 최적화
  - Float32Array/Uint32Array + Base64 인코딩 적용
  - 파일 크기: 714KB → 378KB (47% 감소)
  - GeoJSON 대비: 2.7배 → 1.45배 (합리적 수준)
  - Float16/Uint16 테스트 후 채택하지 않기로 결정 (호환성, 안정성)

- **Phase 2 완료**: HGM 포맷 (JSON 직렬화)
  - 런타임 삼각분할 완전 제거
  - 초기 로딩: 3-7초 → < 0.5초 (10배 개선)
  - 파일 크기: 261KB → 714KB (2.7배, TypedArray 최적화 전)

- **Phase 1 완료**: RegionFeature 병합
  - 드로우콜: 4,320 → 512 (88% 감소)
  - FPS: 24 → 58-60 (+142% 향상)

---

*문서 최종 수정일: 2025년 11월 7일*
*최적화 완료: RegionFeature 병합 (v1.0), HGM 포맷 (v2.0), TypedArray 최적화 (v2.1)*
*현재 파일 크기: 378KB (world-low.hgm v2)*
*테스트 환경: M1 MacBook, Node.js v22.20.0*
